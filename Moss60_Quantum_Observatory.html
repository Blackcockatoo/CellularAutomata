<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Moss60 Quantum Observatory</title>
  <style>
    :root {
      --midnight: #050514;
      --deep-blue: #0a0f24;
      --sun-gold: #ffd700;
      --moss-red: #ff3455;
      --moss-blue: #44aaff;
      --moss-black: #1a1a1a;
      --void: #000000;
      --text: #e4e8ff;
      --panel-glow: rgba(27, 206, 255, 0.12);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 30% 20%, #0a1428 0%, #050514 50%, #000000 100%);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }

    #app {
      display: grid;
      grid-template-columns: 300px 1fr 280px;
      height: 100vh;
      gap: 0;
    }

    .panel {
      background: linear-gradient(135deg, rgba(10, 15, 36, 0.95), rgba(5, 5, 20, 0.98));
      backdrop-filter: blur(12px);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
      overflow-y: auto;
      padding: 16px;
    }

    .panel::-webkit-scrollbar { width: 6px; }
    .panel::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
    .panel::-webkit-scrollbar-thumb { background: rgba(255, 215, 0, 0.4); border-radius: 3px; }

    #main-canvas-area {
      position: relative;
      background: radial-gradient(circle at center, rgba(10, 20, 40, 0.3), rgba(0, 0, 0, 0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }

    h1 {
      font-size: 18px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 12px;
      background: linear-gradient(135deg, var(--sun-gold), var(--moss-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }

    h2 {
      font-size: 12px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin: 16px 0 8px;
      color: var(--sun-gold);
      opacity: 0.9;
      border-bottom: 1px solid rgba(255, 215, 0, 0.2);
      padding-bottom: 4px;
    }

    .control-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .control-group {
      margin-bottom: 12px;
    }

    label {
      font-size: 11px;
      letter-spacing: 0.05em;
      color: rgba(228, 232, 255, 0.85);
      display: block;
      margin-bottom: 4px;
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--sun-gold);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    }

    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 4px;
      color: var(--text);
      font-size: 11px;
      outline: none;
    }

    button {
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(68, 170, 255, 0.15));
      border: 1px solid rgba(255, 215, 0, 0.4);
      border-radius: 6px;
      color: var(--text);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    button:hover {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(68, 170, 255, 0.3));
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.4);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0) scale(0.98);
    }

    button.active {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(68, 170, 255, 0.4));
      box-shadow: 0 0 16px rgba(255, 215, 0, 0.6);
    }

    .mode-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 12px;
    }

    .mode-grid button {
      padding: 6px 8px;
      font-size: 10px;
    }

    .stat-display {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 8px;
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .stat-label {
      color: rgba(255, 215, 0, 0.8);
    }

    .stat-value {
      color: var(--moss-blue);
      font-weight: 600;
    }

    .sequence-display {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 215, 0, 0.15);
      border-radius: 4px;
      padding: 6px;
      margin: 8px 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px;
      line-height: 1.4;
      max-height: 120px;
      overflow-y: auto;
      word-break: break-all;
    }

    .red-seq { color: var(--moss-red); }
    .black-seq { color: #888; }
    .blue-seq { color: var(--moss-blue); }

    #overlay-display {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(5, 5, 20, 0.85);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 6px;
      padding: 10px 14px;
      font-size: 11px;
      pointer-events: none;
      font-family: 'JetBrains Mono', monospace;
    }

    .mode-indicator {
      font-size: 14px;
      font-weight: 700;
      color: var(--sun-gold);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 4px;
    }

    @media (max-width: 1200px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      .panel { display: none; }
      #overlay-display { font-size: 10px; padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- LEFT PANEL: QUANTUM CONTROLS -->
    <div class="panel" id="left-panel">
      <h1>Quantum Observatory</h1>
      <p style="font-size: 10px; opacity: 0.7; margin-bottom: 16px;">
        Base-60 consciousness laboratory for prime discovery and harmonic analysis
      </p>

      <h2>Projection Mode</h2>
      <div class="mode-grid">
        <button class="mode-btn active" data-mode="quantum">Quantum Field</button>
        <button class="mode-btn" data-mode="prime">Prime Lattice</button>
        <button class="mode-btn" data-mode="harmonic">Harmonic Web</button>
        <button class="mode-btn" data-mode="cellular">CA Evolution</button>
        <button class="mode-btn" data-mode="yantra">Yantra Bloom</button>
        <button class="mode-btn" data-mode="cryptic">Cryptic Dance</button>
        <button class="mode-btn" data-mode="hepta">Hepta-Sync</button>
        <button class="mode-btn" data-mode="tesseract">4D Tesseract</button>
      </div>

      <h2>Core Parameters</h2>
      <div class="control-group">
        <label>Quantum Intensity: <span id="intensity-val">0.75</span></label>
        <input type="range" id="intensity" min="0" max="1" step="0.01" value="0.75">
      </div>

      <div class="control-group">
        <label>Rotation Speed: <span id="rotation-val">1.0</span></label>
        <input type="range" id="rotation" min="0.1" max="5" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label>Prime Sensitivity: <span id="prime-sens-val">3</span></label>
        <input type="range" id="prime-sens" min="1" max="10" step="1" value="3">
      </div>

      <div class="control-group">
        <label>Harmonic Depth: <span id="harmonic-val">7</span></label>
        <input type="range" id="harmonic" min="1" max="16" step="1" value="7">
      </div>

      <div class="control-group">
        <label>Layer Complexity: <span id="layers-val">5</span></label>
        <input type="range" id="layers" min="1" max="12" step="1" value="5">
      </div>

      <h2>Lineage Mix</h2>
      <div class="control-group">
        <label>Red Weight: <span id="red-weight-val">1.0</span></label>
        <input type="range" id="red-weight" min="0" max="2" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label>Black Weight: <span id="black-weight-val">1.0</span></label>
        <input type="range" id="black-weight" min="0" max="2" step="0.1" value="1.0">
      </div>

      <div class="control-group">
        <label>Blue Weight: <span id="blue-weight-val">1.0</span></label>
        <input type="range" id="blue-weight" min="0" max="2" step="0.1" value="1.0">
      </div>

      <h2>Transformations</h2>
      <div class="control-row">
        <button id="reset-btn" style="flex: 1;">Reset</button>
        <button id="freeze-btn" style="flex: 1;">Freeze</button>
      </div>
      <div class="control-row">
        <button id="prime-pulse-btn" style="flex: 1;">Prime Pulse</button>
        <button id="invert-btn" style="flex: 1;">Invert</button>
      </div>

      <h2>Moss60 Sequences</h2>
      <div class="sequence-display red-seq" id="red-display">RED: Loading...</div>
      <div class="sequence-display black-seq" id="black-display">BLACK: Loading...</div>
      <div class="sequence-display blue-seq" id="blue-display">BLUE: Loading...</div>
    </div>

    <!-- MAIN CANVAS -->
    <div id="main-canvas-area">
      <canvas id="observatory" width="1400" height="1000"></canvas>
      <div id="overlay-display">
        <div class="mode-indicator" id="mode-name">QUANTUM FIELD</div>
        <div id="overlay-stats"></div>
      </div>
    </div>

    <!-- RIGHT PANEL: ANALYSIS -->
    <div class="panel" id="right-panel">
      <h1>Live Analysis</h1>

      <h2>System State</h2>
      <div class="stat-display">
        <div class="stat-row">
          <span class="stat-label">Frame:</span>
          <span class="stat-value" id="frame-count">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Timestamp:</span>
          <span class="stat-value" id="timestamp">0.00s</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">FPS:</span>
          <span class="stat-value" id="fps">60</span>
        </div>
      </div>

      <h2>Prime Detection</h2>
      <div class="stat-display">
        <div class="stat-row">
          <span class="stat-label">Active Primes:</span>
          <span class="stat-value" id="active-primes">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Prime Density:</span>
          <span class="stat-value" id="prime-density">0%</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Largest Prime:</span>
          <span class="stat-value" id="largest-prime">2</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Twin Primes:</span>
          <span class="stat-value" id="twin-primes">0</span>
        </div>
      </div>

      <h2>Harmonic Analysis</h2>
      <div class="stat-display">
        <div class="stat-row">
          <span class="stat-label">Red Resonance:</span>
          <span class="stat-value" id="red-resonance">0.00</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Black Resonance:</span>
          <span class="stat-value" id="black-resonance">0.00</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Blue Resonance:</span>
          <span class="stat-value" id="blue-resonance">0.00</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Total Coherence:</span>
          <span class="stat-value" id="coherence">0.00</span>
        </div>
      </div>

      <h2>Base-60 State</h2>
      <div class="stat-display">
        <div class="stat-row">
          <span class="stat-label">Current Index:</span>
          <span class="stat-value" id="current-idx">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Red Digit:</span>
          <span class="stat-value" id="red-digit">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Black Digit:</span>
          <span class="stat-value" id="black-digit">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Blue Digit:</span>
          <span class="stat-value" id="blue-digit">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Lukas Sector:</span>
          <span class="stat-value" id="lukas-sector">0</span>
        </div>
      </div>

      <h2>Cryptographic State</h2>
      <div class="stat-display">
        <div class="stat-row">
          <span class="stat-label">Entropy:</span>
          <span class="stat-value" id="entropy">0.000</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">XOR State:</span>
          <span class="stat-value" id="xor-state">0x00</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Mod-60 Sum:</span>
          <span class="stat-value" id="mod60-sum">0</span>
        </div>
      </div>

      <h2>Quick Actions</h2>
      <div class="control-row">
        <button id="screenshot-btn" style="flex: 1;">Screenshot</button>
      </div>
      <div class="control-row">
        <button id="export-state-btn" style="flex: 1;">Export State</button>
      </div>
      <div class="control-row">
        <button id="fullscreen-btn" style="flex: 1;">Fullscreen</button>
      </div>
    </div>
  </div>

  <script>
    // ===== MOSS60 FOUNDATION =====
    const MOSS60 = {
      RED: "113031491493585389543778774590997079619617525721567332336510".split("").map(Number),
      BLACK: "011235831459437077415617853819099875279651673033695493257291".split("").map(Number),
      BLUE: "012776329785893036118967145479098334781325217074992143965631".split("").map(Number),
      LUKAS: [2, 1, 3, 4, 7, 1, 8, 9, 7, 6, 3, 9]
    };

    // Compute Lukas sector boundaries
    MOSS60.LUKAS_BOUNDS = [0];
    let sum = 0;
    for (const d of MOSS60.LUKAS) {
      sum += d;
      MOSS60.LUKAS_BOUNDS.push(sum);
    }

    // Determine lineage per index (0-59)
    MOSS60.LINEAGE = [];
    for (let i = 0; i < 60; i++) {
      const r = MOSS60.RED[i];
      const k = MOSS60.BLACK[i];
      const b = MOSS60.BLUE[i];
      let max = r, lineage = 'red';
      if (b > max) { max = b; lineage = 'blue'; }
      if (k > max) { max = k; lineage = 'black'; }
      MOSS60.LINEAGE.push(lineage);
    }

    MOSS60.getSector = (idx) => {
      const k = ((idx % 60) + 60) % 60;
      for (let s = 0; s < 12; s++) {
        if (k >= MOSS60.LUKAS_BOUNDS[s] && k < MOSS60.LUKAS_BOUNDS[s + 1]) return s;
      }
      return 11;
    };

    MOSS60.getState = (idx) => {
      const k = ((idx % 60) + 60) % 60;
      return {
        idx: k,
        red: MOSS60.RED[k],
        black: MOSS60.BLACK[k],
        blue: MOSS60.BLUE[k],
        lineage: MOSS60.LINEAGE[k],
        sector: MOSS60.getSector(k),
        lukas: MOSS60.LUKAS[MOSS60.getSector(k)]
      };
    };

    // ===== PRIME UTILITIES =====
    const PRIMES = new Set();
    const MAX_PRIME = 1000;

    function buildPrimes(max) {
      for (let n = 2; n <= max; n++) {
        let isPrime = true;
        for (let i = 2; i * i <= n; i++) {
          if (n % i === 0) { isPrime = false; break; }
        }
        if (isPrime) PRIMES.add(n);
      }
    }

    buildPrimes(MAX_PRIME);

    const isPrime = (n) => PRIMES.has(n);

    // ===== CANVAS SETUP =====
    const canvas = document.getElementById('observatory');
    const ctx = canvas.getContext('2d');
    const TAU = Math.PI * 2;

    // ===== STATE =====
    let state = {
      mode: 'quantum',
      running: true,
      frame: 0,
      time: 0,
      lastFrameTime: 0,
      fps: 60,
      intensity: 0.75,
      rotation: 1.0,
      primeSens: 3,
      harmonic: 7,
      layers: 5,
      redWeight: 1.0,
      blackWeight: 1.0,
      blueWeight: 1.0,
      primeCount: 0,
      twinPrimes: 0,
      largestPrime: 2,
      entropy: 0,
      xorState: 0,
      mod60Sum: 0,
      resonance: { red: 0, black: 0, blue: 0, coherence: 0 }
    };

    // ===== UI UPDATES =====
    function updateUI() {
      document.getElementById('frame-count').textContent = state.frame;
      document.getElementById('timestamp').textContent = state.time.toFixed(2) + 's';
      document.getElementById('fps').textContent = Math.round(state.fps);
      
      const currentState = MOSS60.getState(Math.floor(state.time * 10));
      document.getElementById('current-idx').textContent = currentState.idx;
      document.getElementById('red-digit').textContent = currentState.red;
      document.getElementById('black-digit').textContent = currentState.black;
      document.getElementById('blue-digit').textContent = currentState.blue;
      document.getElementById('lukas-sector').textContent = currentState.sector;
      
      document.getElementById('active-primes').textContent = state.primeCount;
      document.getElementById('prime-density').textContent = ((state.primeCount / 60) * 100).toFixed(1) + '%';
      document.getElementById('largest-prime').textContent = state.largestPrime;
      document.getElementById('twin-primes').textContent = state.twinPrimes;
      
      document.getElementById('red-resonance').textContent = state.resonance.red.toFixed(3);
      document.getElementById('black-resonance').textContent = state.resonance.black.toFixed(3);
      document.getElementById('blue-resonance').textContent = state.resonance.blue.toFixed(3);
      document.getElementById('coherence').textContent = state.resonance.coherence.toFixed(3);
      
      document.getElementById('entropy').textContent = state.entropy.toFixed(3);
      document.getElementById('xor-state').textContent = '0x' + state.xorState.toString(16).padStart(2, '0');
      document.getElementById('mod60-sum').textContent = state.mod60Sum;
      
      document.getElementById('mode-name').textContent = state.mode.toUpperCase();
    }

    // ===== DRAWING FUNCTIONS =====
    
    function drawQuantumField(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const N = 2000;
      const maxR = Math.min(w, h) * 0.45;
      
      let primeCount = 0;
      let twinCount = 0;
      let largestPrime = 2;
      
      for (let n = 0; n < N; n++) {
        const idx = n % 60;
        const s = MOSS60.getState(idx);
        
        // Quantum position with prime perturbation
        const baseR = maxR * Math.sqrt(n / N);
        const primeBoost = isPrime(n % 100) ? 1.15 : 1.0;
        const r = baseR * primeBoost * (0.8 + 0.2 * s.lukas / 9);
        
        const baseAngle = (n * TAU / 60) + t * state.rotation * 0.3;
        const sectorOffset = s.sector * (TAU / 12) * 0.1;
        const angle = baseAngle + sectorOffset;
        
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        
        // Color based on lineage with quantum shimmer
        let color;
        const shimmer = 0.6 + 0.4 * Math.sin(t * 3 + n * 0.05);
        
        if (s.lineage === 'red') {
          const intensity = shimmer * state.redWeight;
          color = `rgba(255, 52, 85, ${intensity * state.intensity})`;
        } else if (s.lineage === 'blue') {
          const intensity = shimmer * state.blueWeight;
          color = `rgba(68, 170, 255, ${intensity * state.intensity})`;
        } else {
          const intensity = shimmer * state.blackWeight;
          color = `rgba(255, 215, 0, ${intensity * state.intensity * 0.7})`;
        }
        
        // Size modulation
        const baseSize = 2 + 2 * (s.red + s.black + s.blue) / 27;
        const primeGlow = isPrime(n % 100) ? 1.5 : 1.0;
        const size = baseSize * primeGlow * shimmer;
        
        // Prime tracking
        if (isPrime(n % 100)) {
          primeCount++;
          if (n % 100 > largestPrime) largestPrime = n % 100;
        }
        if (isPrime(n % 100) && isPrime((n + 2) % 100)) twinCount++;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, TAU);
        ctx.fill();
        
        // Prime highlighting
        if (isPrime(n % 100) && state.primeSens > 5) {
          ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 * state.intensity})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
      
      state.primeCount = primeCount;
      state.twinPrimes = twinCount;
      state.largestPrime = largestPrime;
    }
    
    function drawPrimeLattice(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const gridSize = 16;
      const spacing = Math.min(w, h) * 0.9 / gridSize;
      
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const idx = (row * gridSize + col) % 60;
          const s = MOSS60.getState(idx);
          
          const x = cx - (gridSize * spacing / 2) + col * spacing;
          const y = cy - (gridSize * spacing / 2) + row * spacing;
          
          const num = (row * gridSize + col + Math.floor(t * 10)) % 100;
          const prime = isPrime(num);
          
          if (prime) {
            const pulse = 0.7 + 0.3 * Math.sin(t * 4 + row + col);
            const radius = spacing * 0.35 * pulse;
            
            let color;
            if (s.lineage === 'red') color = `rgba(255, 52, 85, ${pulse * state.intensity})`;
            else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${pulse * state.intensity})`;
            else color = `rgba(255, 215, 0, ${pulse * state.intensity * 0.8})`;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, TAU);
            ctx.fill();
            
            // Connection lines between primes
            if (col > 0 && isPrime((row * gridSize + col - 1 + Math.floor(t * 10)) % 100)) {
              ctx.strokeStyle = color.replace(/[\d.]+\)/, '0.2)');
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x - spacing, y);
              ctx.stroke();
            }
          } else {
            ctx.fillStyle = `rgba(100, 100, 100, ${0.15 * state.intensity})`;
            ctx.fillRect(x - 2, y - 2, 4, 4);
          }
        }
      }
    }
    
    function drawHarmonicWeb(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const rings = state.harmonic;
      const maxR = Math.min(w, h) * 0.44;
      
      const points = Array.from({ length: rings }, () => []);
      
      for (let ring = 0; ring < rings; ring++) {
        const baseR = maxR * (ring + 1) / rings;
        
        for (let i = 0; i < 60; i++) {
          const s = MOSS60.getState(i);
          const theta = TAU * i / 60;
          
          // Harmonic wave modulation
          const k = 2 + (s.red % 5);
          const amp = 0.15 + 0.03 * s.lukas;
          const phase = 0.3 * s.lukas + ring * 0.1;
          const wave = 1 + amp * Math.sin(k * theta + t * state.rotation + phase);
          
          const r = baseR * wave;
          const x = cx + r * Math.cos(theta);
          const y = cy + r * Math.sin(theta);
          
          points[ring].push({ x, y, state: s, isPrime: isPrime(i) });
          
          // Draw point
          let color;
          const pulse = 0.6 + 0.4 * Math.sin(t * 2.5 + ring * 0.3 + i * 0.05);
          
          if (s.lineage === 'red') color = `rgba(255, 52, 85, ${pulse * state.intensity})`;
          else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${pulse * state.intensity})`;
          else color = `rgba(255, 215, 0, ${pulse * state.intensity * 0.7})`;
          
          const size = isPrime(i) ? 3 + pulse * 2 : 2;
          
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, TAU);
          ctx.fill();
        }
      }
      
      // Connect rings radially
      for (let i = 0; i < 60; i++) {
        const s = MOSS60.getState(i);
        let color;
        
        if (s.lineage === 'red') color = 'rgba(255, 52, 85, 0.15)';
        else if (s.lineage === 'blue') color = 'rgba(68, 170, 255, 0.15)';
        else color = 'rgba(255, 215, 0, 0.1)';
        
        ctx.strokeStyle = color;
        ctx.lineWidth = isPrime(i) ? 1.5 : 0.5;
        ctx.beginPath();
        
        for (let ring = 0; ring < rings; ring++) {
          const p = points[ring][i];
          if (ring === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }
      
      // Connect circumferentially
      for (let ring = 0; ring < rings; ring++) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.08 + 0.05 * ring / rings})`;
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        
        for (let i = 0; i < 60; i++) {
          const p = points[ring][i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
    
    function drawCellularEvolution(t) {
      const w = canvas.width, h = canvas.height;
      const rows = 40, cols = 60;
      const cellW = w / cols, cellH = h / rows;
      
      const currentRow = Math.floor(t * 2) % rows;
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const idx = col % 60;
          const s = MOSS60.getState(idx);
          
          const seed = (row * 7 + col * 11 + Math.floor(t * 5)) % 256;
          const rule = (90 + s.red * 10 + s.black * 5 + s.blue * 3) % 256;
          
          const alive = ((rule >> (seed % 8)) & 1) === 1;
          
          const x = col * cellW;
          const y = row * cellH;
          
          if (alive) {
            let color;
            const glow = row === currentRow ? 1.0 : 0.6;
            
            if (s.lineage === 'red') color = `rgba(255, 52, 85, ${glow * state.intensity})`;
            else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${glow * state.intensity})`;
            else color = `rgba(255, 215, 0, ${glow * state.intensity * 0.8})`;
            
            ctx.fillStyle = color;
            ctx.fillRect(x, y, cellW + 1, cellH + 1);
            
            if (isPrime(col)) {
              ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, cellW, cellH);
            }
          }
        }
      }
    }
    
    function drawYantraBloom(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const baseR = Math.min(w, h) * 0.4;
      
      ctx.save();
      ctx.translate(cx, cy);
      
      // Concentric circles
      for (let i = 1; i <= 6; i++) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 * i / 6})`;
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, baseR * i / 6, 0, TAU);
        ctx.stroke();
      }
      
      // Rotating triangles
      const layers = state.layers;
      for (let k = 0; k < layers; k++) {
        const r = baseR * (0.3 + 0.6 * k / (layers - 1));
        const s = MOSS60.getState((k * 7) % 60);
        
        let color;
        if (s.lineage === 'red') color = `rgba(255, 52, 85, ${0.5 * state.intensity})`;
        else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${0.5 * state.intensity})`;
        else color = `rgba(255, 215, 0, ${0.4 * state.intensity})`;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        
        const spin = t * state.rotation * 0.3 + k * 0.15;
        
        ctx.save();
        ctx.rotate(spin);
        ctx.beginPath();
        
        for (let i = 0; i < 3; i++) {
          const angle = (TAU / 3) * i - Math.PI / 2;
          const x = r * Math.cos(angle);
          const y = r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      
      // Lukas rays
      for (let i = 0; i < 12; i++) {
        const L = MOSS60.LUKAS[i];
        const lenFactor = 0.5 + 0.4 * (L / 9);
        const r = baseR * lenFactor;
        const angle = (TAU * i / 12) + 0.1 * Math.sin(t + i);
        
        ctx.strokeStyle = `rgba(255, 215, 0, ${0.25 * state.intensity})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle));
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    function drawCrypticDance(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const N = 1000;
      const maxR = Math.min(w, h) * 0.43;
      
      let xorAcc = 0;
      let sumAcc = 0;
      
      for (let n = 0; n < N; n++) {
        const idx = n % 60;
        const s = MOSS60.getState(idx);
        
        // Cryptographic transformation
        const crypt = (s.red ^ s.black ^ s.blue) + ((s.red << 2) | s.black);
        xorAcc ^= crypt;
        sumAcc = (sumAcc + s.red + s.black + s.blue) % 60;
        
        const r = maxR * Math.sqrt(n / N);
        const angle = (n * TAU * 0.618) + (crypt / 255) * TAU + t * state.rotation * 0.2;
        
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        
        const cryptLevel = crypt / 255;
        const hue = (cryptLevel * 360 + t * 20) % 360;
        const sat = 60 + cryptLevel * 40;
        const light = 40 + cryptLevel * 30;
        
        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${state.intensity * 0.7})`;
        
        const size = 1.5 + cryptLevel * 3;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, TAU);
        ctx.fill();
      }
      
      state.xorState = xorAcc;
      state.mod60Sum = sumAcc;
      
      // Calculate entropy
      const digits = [...MOSS60.RED, ...MOSS60.BLACK, ...MOSS60.BLUE];
      const freq = new Array(10).fill(0);
      digits.forEach(d => freq[d]++);
      let entropy = 0;
      freq.forEach(f => {
        if (f > 0) {
          const p = f / digits.length;
          entropy -= p * Math.log2(p);
        }
      });
      state.entropy = entropy;
    }
    
    function drawHeptaSync(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const rings = 7;
      const maxR = Math.min(w, h) * 0.42;
      
      for (let ring = 0; ring < rings; ring++) {
        const r = maxR * (ring + 1) / rings;
        const sides = 7;
        const rotation = t * state.rotation * (ring % 2 === 0 ? 1 : -1);
        
        for (let i = 0; i < sides; i++) {
          const angle1 = (TAU * i / sides) + rotation;
          const angle2 = (TAU * (i + 1) / sides) + rotation;
          
          const x1 = cx + r * Math.cos(angle1);
          const y1 = cy + r * Math.sin(angle1);
          const x2 = cx + r * Math.cos(angle2);
          const y2 = cy + r * Math.sin(angle2);
          
          const idx = (ring * 7 + i) % 60;
          const s = MOSS60.getState(idx);
          
          let color;
          if (s.lineage === 'red') color = `rgba(255, 52, 85, ${0.6 * state.intensity})`;
          else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${0.6 * state.intensity})`;
          else color = `rgba(255, 215, 0, ${0.5 * state.intensity})`;
          
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          
          // Vertices
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x1, y1, 3, 0, TAU);
          ctx.fill();
        }
      }
      
      // Center heptagon
      const centerR = maxR * 0.15;
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < 7; i++) {
        const angle = (TAU * i / 7) - t * state.rotation;
        const x = cx + centerR * Math.cos(angle);
        const y = cy + centerR * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
    }
    
    function drawTesseract(t) {
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const size1 = Math.min(w, h) * 0.3;
      const size2 = size1 * 0.6;
      
      const rotX = t * state.rotation * 0.3;
      const rotY = t * state.rotation * 0.4;
      const rotZ = t * state.rotation * 0.25;
      const rot4D = t * state.rotation * 0.2;
      
      // Project 4D hypercube to 3D to 2D
      const vertices4D = [];
      for (let i = 0; i < 16; i++) {
        const x = (i & 1) ? 1 : -1;
        const y = (i & 2) ? 1 : -1;
        const z = (i & 4) ? 1 : -1;
        const w = (i & 8) ? 1 : -1;
        vertices4D.push([x, y, z, w]);
      }
      
      const project = (v) => {
        let [x, y, z, w] = v;
        
        // 4D rotation
        const c4 = Math.cos(rot4D), s4 = Math.sin(rot4D);
        [x, w] = [x * c4 - w * s4, x * s4 + w * c4];
        
        // 3D rotations
        const cx = Math.cos(rotX), sx = Math.sin(rotX);
        [y, z] = [y * cx - z * sx, y * sx + z * cx];
        
        const cy = Math.cos(rotY), sy = Math.sin(rotY);
        [x, z] = [x * cy + z * sy, -x * sy + z * cy];
        
        // 4D to 3D projection
        const dist4D = 3;
        const scale3D = dist4D / (dist4D - w);
        x *= scale3D;
        y *= scale3D;
        z *= scale3D;
        
        // 3D to 2D projection
        const dist3D = 4;
        const scale2D = dist3D / (dist3D - z);
        
        return {
          x: cx + x * size1 * scale2D,
          y: cy + y * size1 * scale2D,
          depth: z
        };
      };
      
      const projected = vertices4D.map(v => project(v));
      
      // Draw edges
      const edges = [
        [0,1],[1,3],[3,2],[2,0], // Front face
        [4,5],[5,7],[7,6],[6,4], // Back face
        [0,4],[1,5],[2,6],[3,7], // Connecting edges
        [8,9],[9,11],[11,10],[10,8], // Inner front
        [12,13],[13,15],[15,14],[14,12], // Inner back
        [8,12],[9,13],[10,14],[11,15], // Inner connecting
        [0,8],[1,9],[2,10],[3,11], // Outer to inner front
        [4,12],[5,13],[6,14],[7,15] // Outer to inner back
      ];
      
      edges.forEach(([i, j]) => {
        const p1 = projected[i];
        const p2 = projected[j];
        
        const avgDepth = (p1.depth + p2.depth) / 2;
        const alpha = 0.2 + 0.6 * ((avgDepth + 2) / 4);
        
        const idx = (i + j) % 60;
        const s = MOSS60.getState(idx);
        
        let color;
        if (s.lineage === 'red') color = `rgba(255, 52, 85, ${alpha * state.intensity})`;
        else if (s.lineage === 'blue') color = `rgba(68, 170, 255, ${alpha * state.intensity})`;
        else color = `rgba(255, 215, 0, ${alpha * state.intensity * 0.8})`;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = isPrime(i + j) ? 2 : 1;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      });
      
      // Draw vertices
      projected.forEach((p, i) => {
        const size = 4 * ((p.depth + 2) / 4);
        const s = MOSS60.getState(i % 60);
        
        let color;
        if (s.lineage === 'red') color = 'rgba(255, 52, 85, 0.9)';
        else if (s.lineage === 'blue') color = 'rgba(68, 170, 255, 0.9)';
        else color = 'rgba(255, 215, 0, 0.8)';
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, TAU);
        ctx.fill();
      });
    }
    
    // ===== MODE DISPATCHER =====
    const modes = {
      quantum: drawQuantumField,
      prime: drawPrimeLattice,
      harmonic: drawHarmonicWeb,
      cellular: drawCellularEvolution,
      yantra: drawYantraBloom,
      cryptic: drawCrypticDance,
      hepta: drawHeptaSync,
      tesseract: drawTesseract
    };
    
    // ===== ANIMATION LOOP =====
    function animate(timestamp) {
      if (!state.running) return;
      
      const dt = timestamp - state.lastFrameTime;
      state.fps = 1000 / dt;
      state.lastFrameTime = timestamp;
      state.time = timestamp / 1000;
      state.frame++;
      
      // Clear canvas
      ctx.fillStyle = 'rgba(5, 5, 20, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw current mode
      modes[state.mode](state.time);
      
      // Calculate resonance
      const idx = Math.floor(state.time * 10) % 60;
      const s = MOSS60.getState(idx);
      
      state.resonance.red = (s.red / 9) * state.redWeight;
      state.resonance.black = (s.black / 9) * state.blackWeight;
      state.resonance.blue = (s.blue / 9) * state.blueWeight;
      state.resonance.coherence = (state.resonance.red + state.resonance.black + state.resonance.blue) / 3;
      
      // Update UI
      if (state.frame % 10 === 0) updateUI();
      
      requestAnimationFrame(animate);
    }
    
    // ===== EVENT HANDLERS =====
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.mode = btn.getAttribute('data-mode');
      });
    });
    
    const sliders = {
      intensity: (v) => { state.intensity = v; document.getElementById('intensity-val').textContent = v; },
      rotation: (v) => { state.rotation = v; document.getElementById('rotation-val').textContent = v; },
      'prime-sens': (v) => { state.primeSens = v; document.getElementById('prime-sens-val').textContent = v; },
      harmonic: (v) => { state.harmonic = Math.round(v); document.getElementById('harmonic-val').textContent = Math.round(v); },
      layers: (v) => { state.layers = Math.round(v); document.getElementById('layers-val').textContent = Math.round(v); },
      'red-weight': (v) => { state.redWeight = v; document.getElementById('red-weight-val').textContent = v; },
      'black-weight': (v) => { state.blackWeight = v; document.getElementById('black-weight-val').textContent = v; },
      'blue-weight': (v) => { state.blueWeight = v; document.getElementById('blue-weight-val').textContent = v; }
    };
    
    Object.keys(sliders).forEach(id => {
      const input = document.getElementById(id);
      input.addEventListener('input', (e) => {
        sliders[id](parseFloat(e.target.value));
      });
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      state.time = 0;
      state.frame = 0;
    });
    
    document.getElementById('freeze-btn').addEventListener('click', () => {
      state.running = !state.running;
      document.getElementById('freeze-btn').textContent = state.running ? 'Freeze' : 'Resume';
      if (state.running) requestAnimationFrame(animate);
    });
    
    document.getElementById('prime-pulse-btn').addEventListener('click', () => {
      state.primeSens = 10;
      document.getElementById('prime-sens').value = 10;
      document.getElementById('prime-sens-val').textContent = 10;
      setTimeout(() => {
        state.primeSens = 3;
        document.getElementById('prime-sens').value = 3;
        document.getElementById('prime-sens-val').textContent = 3;
      }, 1000);
    });
    
    document.getElementById('invert-btn').addEventListener('click', () => {
      [state.redWeight, state.blueWeight] = [state.blueWeight, state.redWeight];
      document.getElementById('red-weight').value = state.redWeight;
      document.getElementById('blue-weight').value = state.blueWeight;
      document.getElementById('red-weight-val').textContent = state.redWeight.toFixed(1);
      document.getElementById('blue-weight-val').textContent = state.blueWeight.toFixed(1);
    });
    
    document.getElementById('fullscreen-btn').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
    
    document.getElementById('screenshot-btn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = `moss60_${state.mode}_${Date.now()}.png`;
      link.href = canvas.toDataURL();
      link.click();
    });
    
    document.getElementById('export-state-btn').addEventListener('click', () => {
      const exportData = JSON.stringify({
        mode: state.mode,
        parameters: {
          intensity: state.intensity,
          rotation: state.rotation,
          primeSens: state.primeSens,
          harmonic: state.harmonic,
          layers: state.layers,
          weights: {
            red: state.redWeight,
            black: state.blackWeight,
            blue: state.blueWeight
          }
        },
        timestamp: state.time
      }, null, 2);
      
      const blob = new Blob([exportData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = `moss60_state_${Date.now()}.json`;
      link.href = url;
      link.click();
      URL.revokeObjectURL(url);
    });
    
    // Display sequences in UI
    document.getElementById('red-display').textContent = 'RED: ' + MOSS60.RED.join('');
    document.getElementById('black-display').textContent = 'BLACK: ' + MOSS60.BLACK.join('');
    document.getElementById('blue-display').textContent = 'BLUE: ' + MOSS60.BLUE.join('');
    
    // ===== START =====
    updateUI();
    requestAnimationFrame(animate);
    
    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        e.preventDefault();
        document.getElementById('freeze-btn').click();
      } else if (e.key >= '1' && e.key <= '8') {
        const modes = ['quantum', 'prime', 'harmonic', 'cellular', 'yantra', 'cryptic', 'hepta', 'tesseract'];
        const idx = parseInt(e.key) - 1;
        if (idx < modes.length) {
          state.mode = modes[idx];
          document.querySelectorAll('.mode-btn').forEach((btn, i) => {
            btn.classList.toggle('active', i === idx);
          });
        }
      }
    });
  </script>
</body>
</html>
